type UserProfile = 
 record {
   city: opt text;
   country: opt text;
   created: int;
   dataVolumeKB: nat;
   devices: vec text;
   ipAddress: opt text;
   isActive: bool;
   lastActive: int;
   lastLogin: int;
   latitude: opt float64;
   longitude: opt float64;
   points: nat;
   preferences: record {
                  notificationsEnabled: bool;
                  theme: text;
                };
   "principal": principal;
   referralCode: text;
   referralCount: nat;
   referredBy: opt principal;
   region: opt text;
   scrapedUrls: vec text;
   totalDataScraped: nat;
 };
type ScrapingTopic = 
 record {
   activeHours: record {
                  end: nat;
                  start: nat;
                };
   aiConfig: AIConfig;
   createdAt: int;
   description: text;
   extractionRules: ExtractionRules;
   geolocationFilter: opt text;
   id: text;
   maxRetries: nat;
   name: text;
   percentageNodes: opt nat;
   randomizationMode: opt text;
   scrapingInterval: nat;
   status: text;
   urlPatterns: vec text;
 };
type ScrapingField = 
 record {
   aiPrompt: opt text;
   fieldType: text;
   name: text;
   required: bool;
 };
type ScrapedData = 
 record {
   client_id: principal;
   content: text;
   id: text;
   scraping_time: int;
   source: text;
   status: text;
   timestamp: int;
   topic: text;
   url: text;
 };
type RhinoScanStats = 
 record {
   activeNodes: nat;
   countriesCount: nat;
   nodesByCountry: vec record {
                         text;
                         nat;
                       };
   recentActivity: vec NodeActivity;
   totalDataVolumeKB: nat;
   totalNodes: nat;
 };
type Result_6 = 
 variant {
   err: Error;
   ok: UserProfile;
 };
type Result_5 = 
 variant {
   err: text;
   ok: text;
 };
type Result_4 = 
 variant {
   err: Error;
   ok: vec ScrapedData;
 };
type Result_3 = 
 variant {
   err: Error;
   ok: vec ScrapingTopic;
 };
type Result_2 = 
 variant {
   err: text;
   ok: UserProfile;
 };
type Result_1 = 
 variant {
   err: Error;
   ok;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type NodeActivity = 
 record {
   city: opt text;
   country: opt text;
   dataVolumeKB: nat;
   lastActive: int;
   "principal": principal;
   region: opt text;
 };
type GeographicDistribution = 
 record {
   coordinates: opt record {
                      lat: float64;
                      lng: float64;
                    };
   country: text;
   dataVolumeKB: nat;
   nodeCount: nat;
   region: opt text;
 };
type ExtractionRules = 
 record {
   customPrompt: opt text;
   fields: vec ScrapingField;
 };
type Error = 
 variant {
   AlreadyExists;
   InvalidInput: text;
   NotAuthorized;
   NotFound;
   SystemError: text;
 };
type CostLimits = 
 record {
   maxConcurrent: nat;
   maxDailyCost: float64;
   maxMonthlyCost: float64;
 };
type AIConfig = 
 record {
   apiKey: text;
   costLimits: CostLimits;
   model: text;
 };
service : {
  awardPoints: (principalId: principal, points: nat) -> (Result);
  getNodeGeography: () -> (vec GeographicDistribution) query;
  getNodeStatus: ("principal": principal) ->
   (opt
     record {
       country: opt text;
       dataVolumeKB: nat;
       isActive: bool;
       lastActive: int;
       points: nat;
     }) query;
  getProfile: () -> (Result_6);
  getReferralCode: () -> (Result_5);
  getRhinoScanStats: () -> (RhinoScanStats) query;
  getScrapedData: (topicIds: vec text) -> (Result_4);
  getTopContributors: (limit: nat) -> (vec record {
                                             principal;
                                             nat;
                                           }) query;
  getTopics: () -> (Result_3);
  getUserData: () -> (Result_2);
  getUserScrapedUrls: () -> (vec text);
  hasUserScrapedUrl: (url: text) -> (bool);
  registerDevice: (deviceId: text) -> (Result_1);
  submitScrapedData: (data: ScrapedData) -> (Result_1);
  updatePreferences: (notificationsEnabled: bool, theme: text) -> (Result_1);
  updateUserLogin: (ipAddress: text) -> (Result);
  useReferralCode: (code: text) -> (Result);
}
