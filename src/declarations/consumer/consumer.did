type UserProfileBackup = 
 record {
   created: int;
   devices: vec text;
   lastLogin: int;
   points: nat;
   pointsFromReferrals: nat;
   pointsFromScraping: nat;
   "principal": principal;
   referralCode: text;
   referralCount: nat;
   referredBy: opt principal;
   totalBandwidthUsed: nat;
   totalDataScraped: nat;
   totalPagesScraped: nat;
 };
type UserProfile = 
 record {
   city: opt text;
   country: opt text;
   created: int;
   dataVolumeKB: nat;
   devices: vec text;
   ipAddress: opt text;
   isActive: bool;
   lastActive: int;
   lastLogin: int;
   latitude: opt float64;
   longitude: opt float64;
   points: nat;
   pointsFromReferrals: nat;
   pointsFromScraping: nat;
   preferences: record {
                  notificationsEnabled: bool;
                  theme: text;
                };
   "principal": principal;
   referralCode: text;
   referralCount: nat;
   referralHistory: vec ReferralUse;
   referredBy: opt principal;
   region: opt text;
   scrapedUrls: vec text;
   sessionBandwidthUsed: nat;
   sessionPagesScraped: nat;
   totalBandwidthUsed: nat;
   totalDataScraped: nat;
   totalPagesScraped: nat;
 };
type ScrapingTopic = 
 record {
   activeHours: record {
                  end: nat;
                  start: nat;
                };
   aiConfig: AIConfig;
   createdAt: int;
   description: text;
   extractionRules: ExtractionRules;
   geolocationFilter: opt text;
   id: text;
   maxRetries: nat;
   name: text;
   percentageNodes: opt nat;
   randomizationMode: opt text;
   scrapingInterval: nat;
   status: text;
   urlPatterns: vec text;
 };
type ScrapingField = 
 record {
   aiPrompt: opt text;
   fieldType: text;
   name: text;
   required: bool;
 };
type ScrapedData = 
 record {
   client_id: principal;
   content: text;
   id: text;
   scraping_time: int;
   source: text;
   status: text;
   timestamp: int;
   topic: text;
   url: text;
 };
type RhinoScanStats = 
 record {
   activeNodes: nat;
   countriesCount: nat;
   nodesByCountry: vec record {
                         text;
                         nat;
                       };
   recentActivity: vec NodeActivity;
   totalDataVolumeKB: nat;
   totalNodes: nat;
 };
type Result_9 = 
 variant {
   err: text;
   ok: vec ConversionRequest;
 };
type Result_8 = 
 variant {
   err: text;
   ok: vec PointsRecord;
 };
type Result_7 = 
 variant {
   err: Error;
   ok: UserProfile;
 };
type Result_6 = 
 variant {
   err: Error;
   ok: vec ScrapedData;
 };
type Result_5 = 
 variant {
   err: Error;
   ok: vec ScrapingTopic;
 };
type Result_4 = 
 variant {
   err: text;
   ok: vec ScrapingTopic;
 };
type Result_3 = 
 variant {
   err: text;
   ok: UserProfile;
 };
type Result_2 = 
 variant {
   err: Error;
   ok;
 };
type Result_12 = 
 variant {
   err: text;
   ok: int;
 };
type Result_11 = 
 variant {
   err: text;
   ok: ConversionRequest;
 };
type Result_10 = 
 variant {
   err: text;
   ok:
    record {
      conversionRequests: vec record {
                                text;
                                ConversionRequest;
                              };
      pointsHistory: vec record {
                           principal;
                           vec PointsRecord;
                         };
      profiles: vec record {
                      principal;
                      UserProfileBackup;
                    };
    };
 };
type Result_1 = 
 variant {
   err: text;
   ok;
 };
type Result = 
 variant {
   err: text;
   ok: text;
 };
type ReferralUse = 
 record {
   pointsAwarded: nat;
   timestamp: int;
   userPrincipal: principal;
 };
type PointsRecord = 
 record {
   amount: nat;
   earnedAt: int;
   source: text;
 };
type NodeActivity = 
 record {
   city: opt text;
   country: opt text;
   dataVolumeKB: nat;
   lastActive: int;
   "principal": principal;
   region: opt text;
 };
type GeographicDistribution = 
 record {
   coordinates: opt record {
                      lat: float64;
                      lng: float64;
                    };
   country: text;
   dataVolumeKB: nat;
   nodeCount: nat;
   region: opt text;
 };
type ExtractionRules = 
 record {
   customPrompt: opt text;
   fields: vec ScrapingField;
 };
type Error = 
 variant {
   AlreadyExists;
   InvalidInput: text;
   NotAuthorized;
   NotFound;
   SystemError: text;
 };
type CostLimits = 
 record {
   maxConcurrent: nat;
   maxDailyCost: float64;
   maxMonthlyCost: float64;
 };
type ConversionRequest = 
 record {
   id: text;
   pointsAmount: nat;
   requestedAt: int;
   status: text;
   tokensFee: nat;
   tokensGross: nat;
   tokensNet: nat;
   userId: principal;
   walletAddress: text;
 };
type AIConfig = 
 record {
   apiKey: text;
   costLimits: CostLimits;
   model: text;
 };
service : {
  awardPoints: (principalId: principal, points: nat) -> (Result_1);
  createBackupSnapshot: (backupCanisterId: text) -> (Result_12);
  createConversionRequest: (pointsAmount: nat, walletAddress: text) ->
   (Result_11);
  exportForBackup: () -> (Result_10);
  fixAllKazakhstanUsers: () -> (Result);
  fixExistingUsersData: () -> (Result);
  fixUserGeolocation: (principalId: principal) -> (Result_1);
  getAllConversionRequests: () -> (Result_9) query;
  getAllUsers: () -> (vec record {
                            principal;
                            UserProfile;
                          }) query;
  getBackupInfo: () ->
   (record {
      totalConversionRequests: nat;
      totalPointsRecords: nat;
      totalProfiles: nat;
    }) query;
  getConversionRequests: (userId: principal) -> (Result_9) query;
  getNodeGeography: () -> (vec GeographicDistribution) query;
  getNodeStatus: ("principal": principal) ->
   (opt
     record {
       country: opt text;
       dataVolumeKB: nat;
       isActive: bool;
       lastActive: int;
       points: nat;
     }) query;
  getPointsHistory: (userId: principal) -> (Result_8) query;
  getProfile: () -> (Result_7);
  getReferralCode: () -> (Result);
  getRhinoScanStats: () -> (RhinoScanStats) query;
  getScrapedData: (topicIds: vec text) -> (Result_6);
  getTopContributors: (limit: nat) -> (vec record {
                                             principal;
                                             nat;
                                           }) query;
  getTopics: () -> (Result_5);
  getTopicsForUser: (userPrincipal: principal) -> (Result_4);
  getUserData: () -> (Result_3);
  getUserScrapedUrls: () -> (vec text);
  hasUserScrapedUrl: (url: text) -> (bool);
  mergeDuplicateUsers: (targetPrincipal: principal) -> (Result);
  populateReferralCodes: () -> (Result);
  recalculateAllUsersPoints: () -> (Result);
  recalculatePointsBreakdown: () -> (Result);
  refreshAllEmptyLocations: () -> (Result);
  refreshUserGeolocation: (targetPrincipal: principal) -> (Result);
  registerDevice: (deviceId: text) -> (Result_2);
  submitScrapedData: (data: ScrapedData) -> (Result_2);
  updateAllUsersGeoFromAPI: () -> (Result);
  updatePreferences: (notificationsEnabled: bool, theme: text) -> (Result_2);
  updateUserLocationByIP: (ipAddress: text, country: text, region: text,
   city: text) -> (Result);
  updateUserLogin: (ipAddress: text) -> (Result_1);
  updateUserLoginForPrincipal: (principalId: principal, ipAddress: text) ->
   (Result);
  useReferralCode: (code: text) -> (Result_1);
  useReferralCodeForPrincipal: (principalId: principal, code: text) ->
   (Result);
}
