type Storage = 
 service {
   addAuthorizedCanister: (id: principal) -> (Result);
   clearAllData: () -> (Result);
   deleteScrapedData: (id: text) -> (Result);
   deleteTopic: (id: text) -> (Result);
   forwardCycles: (target: principal, amount: nat) -> (Result);
   getAIConfig: () -> (Result_3) query;
   getAuthorizedCanisters: () -> (Result_2) query;
   getCycleBalance: () -> (nat) query;
   getScrapedData: (topicIds: vec text) -> (vec ScrapedData) query;
   getTopics: () -> (Result_1) query;
   removeAuthorizedCanister: (id: principal) -> (Result);
   storeScrapedData: (data: ScrapedData) -> (Result);
   updateAIConfig: (config: AIConfig) -> (Result);
   updateTopic: (topic: ScrapingTopic) -> (Result);
   wallet_receive: () -> ();
 };
type ScrapingTopic = 
 record {
   activeHours: record {
                  end: nat;
                  start: nat;
                };
   aiConfig: AIConfig;
   createdAt: int;
   description: text;
   extractionRules: ExtractionRules;
   geolocationFilter: opt text;
   id: text;
   maxRetries: nat;
   name: text;
   percentageNodes: opt nat;
   randomizationMode: opt text;
   scrapingInterval: nat;
   status: text;
   urlPatterns: vec text;
 };
type ScrapingField = 
 record {
   aiPrompt: opt text;
   fieldType: text;
   name: text;
   required: bool;
 };
type ScrapedData = 
 record {
   client_id: principal;
   content: text;
   id: text;
   scraping_time: int;
   source: text;
   status: text;
   timestamp: int;
   topic: text;
   url: text;
 };
type Result_3 = 
 variant {
   err: Error;
   ok: AIConfig;
 };
type Result_2 = 
 variant {
   err: Error;
   ok: vec principal;
 };
type Result_1 = 
 variant {
   err: Error;
   ok: vec ScrapingTopic;
 };
type Result = 
 variant {
   err: Error;
   ok;
 };
type ExtractionRules = 
 record {
   customPrompt: opt text;
   fields: vec ScrapingField;
 };
type Error = 
 variant {
   AlreadyExists;
   InvalidInput: text;
   NotAuthorized;
   NotFound;
   SystemError: text;
 };
type CostLimits = 
 record {
   maxConcurrent: nat;
   maxDailyCost: float64;
   maxMonthlyCost: float64;
 };
type AIConfig = 
 record {
   apiKey: text;
   costLimits: CostLimits;
   model: text;
 };
service : () -> Storage
